# Технічне завдання

#### **Лабораторна робота 8 (LW8)**
> -	Необхідно реалізувати систему реєстрації клієнтів за допомогою патерну Фасад (Фасад (Facade))
> Завдання патерну Фасад полягає в тому, щоб зробити процес реєстрації клієнта простим і зрозумілим. Замість того, щоб клієнтський код викликав кожну окрему частину процесу, він просто викликає метод RegisterCustomer класу CustomerRegistration, який самостійно виконує всі необхідні кроки: перевірку клієнта, збереження даних та надсилання реєстраційного листа.
Освновні складові:
>>    1. Клас Customer (Клієнт): Містить дані про клієнта, такі як його ім'я, електронна пошта, мобільний номер та адреса. Додаткові властивості можуть бути додані згідно з бізнес-вимогами.
>>    2. Клас Validator (Перевірка): Містить методи для перевірки коректності даних клієнта. Метод ValidateCustomer перевіряє дані клієнта і виводить їх на екран.
>>    3. Клас CustomerDataAccessLayer (Рівень доступу до даних клієнта): Містить методи для збереження даних клієнта в базі даних. Метод SaveCustomer зберігає дані клієнта в базі даних і повертає прапорець успішності операції.
>>    4. Клас Email (Електронна пошта): Містить методи для відправлення реєстраційного листа клієнту. Метод SendRegistrationEmail надсилає електронний лист з підтвердженням реєстрації.
>>    5. Клас CustomerRegistration (Реєстрація клієнта): Містить метод RegisterCustomer, який координує процес реєстрації клієнта. Він викликає методи інших класів відповідно до потрібних кроків реєстрації: перевірка клієнта, збереження даних клієнта і надсилання реєстраційного листа.
>>    6. Клас Program (Головна програма): Містить точку входу в програму. У методі Main створюється екземпляр класу Customer з відповідними даними клієнта. Потім створюється екземпляр класу CustomerRegistration і викликається метод RegisterCustomer для реєстрації клієнта.

> - Реалізувати завантаження зображень в інтернет-магазині за допомогою патерну Проксі (Замісник (Проксі))
У контексті інтернет-магазину, коли користувач переглядає сторінку товару, можуть бути виведені зображення, що демонструють товар. Завантаження цих зображень може вимагати часу та ресурсів.
>> - Основна мета використання патерну Замісник (Проксі) полягає в тому, щоб створити об'єкт-проксі, який може контролювати доступ до іншого об'єкта (у цьому випадку, ImageLoader). Проксі може виконувати різні функції, такі як аутентифікація, авторизація, кешування, оптимізація, обмеження доступу та інше.
>> - Якщо значення null, створиться екземпляр, а потім на екземплярі imageLoader можна викликати метод DisplayImage. З іншого боку, якщо екземпляр imageLoader не є нульовим, він не створить екземпляр, замість цього він використовуватиме наявний екземпляр imageLoader для виклику методу DisplayImage.
> Кроки реалізації:
>> 1. Необхідно створити інтерфейс IImageLoader, який визначатиме метод DisplayImage(), що відображатиме зображення.
>> 2. Створити клас ImageLoader, який реалізуватиме інтерфейс IImageLoader. Цей клас буде відповідати за завантаження та відображення зображень з сервера. У конструкторі ImageLoader передається URL зображення для завантаження.
>> 3. В класі ImageLoader реалізувати приватний метод LoadImageFromServer(), який буде виконувати завантаження зображення з сервера.
>> 4. Створити клас ImageLoaderProxy, який також реалізуватиме інтерфейс IImageLoader. Цей клас буде виступати як проксі і контролюватиме доступ до реального об'єкта ImageLoader. У конструкторі ImageLoaderProxy передається URL зображення для завантаження.
>> 5. В класі ImageLoaderProxy створити приватне поле imageUrl, яке зберігатиме URL зображення для завантаження.
>> 6. В класі ImageLoaderProxy реалізувати метод DisplayImage(), який буде перевіряти, чи існує екземпляр ImageLoader. Якщо такого екземпляра немає, то створити його і викликати метод DisplayImage() на цьому екземплярі. У протилежному випадку, просто викликати метод DisplayImage() на вже існуючому екземплярі.
>> 7. У Main методі або відповідному місці додатку створити екземпляр ImageLoaderProxy з вказаним URL зображення.
>> 8. Викликати метод DisplayImage() на створеному екземплярі ImageLoaderProxy для завантаження та відображення зображення.
> -	Реалізувати способу зв'язку клієнта з контактним центром (Міст (Bridge))
> В коді застосовано патерн "Міст" (Bridge) для розділення абстракції (клас "Customer") від реалізації (класи "EmailContactCenter" і "PhoneContactCenter") для забезпечення гнучкості і можливості зміни способу зв'язку з контактним центром.
> У патерні "Міст" є дві головні складові:
>> 1. Абстракція (Abstraction): Це представлено класом "Customer". Він має метод ContactCustomerSupport(), який використовує об'єкт типу ContactCenter для взаємодії з контактним центром. Клас "Customer" використовує цей об'єкт ContactCenter для виклику методів SendRequest() та ReceiveResponse(), які представляють загальні дії зв'язку з контактним центром. Абстракція дозволяє клієнту взаємодіяти з контактним центром без прив'язки до конкретного способу зв'язку.
>> 2. Реалізація (Implementation): Це представлено класами "EmailContactCenter" і "PhoneContactCenter". Вони розширюють клас "ContactCenter", який визначає загальний інтерфейс для всіх способів зв'язку з контактним центром. Кожен з цих класів надає власну реалізацію методів SendRequest() та ReceiveResponse(), а також додаткові специфічні методи, такі як SendEmail(), ReceiveEmail(), MakeCall() та ReceiveCall(). Реалізація може варіюватись між різними способами зв'язку, наприклад, електронною поштою чи телефонним дзвінком.

> Завдяки патерну "Міст" можна легко додавати нові класи для реалізації різних способів зв'язку з контактним центром, а також нові методи вже існуючих класів, не змінюючи структуру клієнтського коду. Клас "Customer" використовує об'єкт ContactCenter, щоб взаємодіяти з контактним центром без необхідності знати деталі реалізації конкретного способу зв'язку. Це забезпечує гнучкість, розширюваність і легкість підтримки системи, що використовує патерн "Міст".
